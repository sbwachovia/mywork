/** *  */package com.bolla.sri.base.dao;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Optional;import javax.inject.Inject;import javax.persistence.EntityManager;import javax.persistence.LockModeType;import javax.persistence.NonUniqueResultException;import javax.persistence.Query;import javax.persistence.TypedQuery;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Join;import javax.persistence.criteria.JoinType;import javax.persistence.criteria.Order;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;import javax.persistence.criteria.Selection;import org.jboss.logging.Logger;import com.bolla.sri.base.dao.criteria.Criteria;import com.bolla.sri.base.dao.criteria.CriteriaElement;import com.bolla.sri.base.dao.criteria.CriteriaWhere;import com.bolla.sri.base.dao.nativecriteria.NativeCriteria;import com.bolla.sri.base.dao.nativecriteria.NativeCriteriaBuilder;import com.bolla.sri.base.domain.EditableDTO;public abstract class GenericBaseDao<T, ID extends Serializable> implements IBaseDao<T, ID> { private static final Logger logger = Logger.getLogger(GenericBaseDao.class); @Inject private NativeCriteriaBuilder nativeBuilder; protected Class<T> entityClass; @SuppressWarnings("unchecked") protected Class<T> getEntityClass() {  if (this.entityClass == null) {   this.entityClass = ((Class<T>) ((ParameterizedType) this.getClass().getGenericSuperclass())     .getActualTypeArguments()[0]);  }  return this.entityClass; } /**  * Override this method to have own entity manager.  *   * @return  */ protected EntityManager getEntityManager() {  throw new IllegalAccessError("getEntityManager() must be overridden"); } @Override public T persist(T entity) {  getEntityManager().persist(entity);  logger.debug("Persisting entity : " + getEntityClass().getName());  return entity; } @Override public Optional<EditableDTO> isEditable(ID id) {  EditableDTO dto = null;  Query query = getEntityManager().createQuery(    "select modifiedBy, changePending from " + getEntityClass().getSimpleName() + " where id = :ID");  query.setParameter("ID", id);  List<?> list = query.getResultList();  if (!list.isEmpty() && list.get(0) != null) {   dto = new EditableDTO();   Object[] obj = (Object[]) list.get(0);   dto.setModifiedBy(Optional.ofNullable(obj[0]).map(o -> o.toString()).orElse(null));   dto.setChangePending(Boolean.valueOf(obj[1].toString()));  }  return Optional.ofNullable(dto); } @Override public Optional<T> findById(ID id) {  logger.debug("Finding entity by Id: " + id);  return Optional.ofNullable(getEntityManager().find(getEntityClass(), id)); } @Override public Optional<T> findById(ID id, LockModeType lockType) {  logger.info("Finding entity with lock by Id: " + id);  return Optional.ofNullable(getEntityManager().find(getEntityClass(), id, lockType)); } @Override public List<T> findAll() {  Class<T> clazz = getEntityClass();  logger.debug("Finding All in Entity " + clazz.getCanonicalName());  final TypedQuery<T> query = getEntityManager().createQuery("from " + clazz.getCanonicalName(), clazz);  return query.getResultList(); } @Override public T update(T entity) {  logger.debug("Merging entity");  getEntityManager().merge(entity);  return entity; } @Override public void remove(T entity) {  logger.debug("Remove entity");  getEntityManager().remove(entity); } @SuppressWarnings("unchecked") @Override public Optional<?> findOneByNamedQuery(final String name, final Map<String, ? extends Object> params)   throws NonUniqueResultException {  Query namedQuery = getEntityManager().createNamedQuery(name);  Optional.ofNullable(params).ifPresent(p -> {   p.forEach((key, value) -> {    namedQuery.setParameter(key, value);   });  });  List<Object> list = namedQuery.getResultList();  if (list.size() > 1)   throw new NonUniqueResultException("No Unique found - Records found : " + list.size());  return list.stream().findFirst(); } @Override public Optional<List<?>> findByNamedQuery(String queryName, Map<String, ? extends Object> params) {  Query namedQuery = getEntityManager().createNamedQuery(queryName);  Optional.ofNullable(params).ifPresent(p -> {   p.forEach((key, value) -> {    namedQuery.setParameter(key, value);   });  });  return Optional.of(namedQuery.getResultList()); } @Override public Optional<List<?>> findByNamedQuery(String queryName, Map<String, ? extends Object> params, int startFrom,   int maxResults) {  Query namedQuery = getEntityManager().createNamedQuery(queryName);  Optional.ofNullable(params).ifPresent(p -> {   p.forEach((key, value) -> {    namedQuery.setParameter(key, value);   });  });  return Optional.of(namedQuery.setFirstResult(startFrom).setMaxResults(maxResults).getResultList()); } @Override public Long getCountByCriteria(Criteria clause) {  CriteriaBuilder builder = getEntityManager().getCriteriaBuilder();  Class<T> entityClazz = getEntityClass();  CriteriaQuery<Long> criteriaQuery = builder.createQuery(Long.class);  Root<T> root = null;  if (clause.getEntityClazz() == null)   root = criteriaQuery.from(entityClazz);  else   root = criteriaQuery.from(clause.getEntityClazz());  Restrictions restrictions = new Restrictions();  createCriteria(clause.getWhere(), criteriaQuery, builder, root, null, restrictions);  criteriaQuery.select(builder.countDistinct(root));  return getEntityManager().createQuery(criteriaQuery).getSingleResult(); } @Override public boolean isExists(ID id) {  CriteriaBuilder builder = getEntityManager().getCriteriaBuilder();  Class<T> entityClazz = getEntityClass();  CriteriaQuery<Long> criteriaQuery = builder.createQuery(Long.class);  Root<T> root = criteriaQuery.from(entityClazz);  criteriaQuery.where(builder.equal(root.get("id"), id));  criteriaQuery.select(builder.countDistinct(root));  return getEntityManager().createQuery(criteriaQuery).getSingleResult() > 0; } @Override public Long getCountByNamedQuery(String queryName, Map<String, ? extends Object> params) {  Query namedQuery = getEntityManager().createNamedQuery(queryName);  Optional.ofNullable(params).ifPresent(p -> {   p.forEach((key, value) -> {    namedQuery.setParameter(key, value);   });  });  return (Long) namedQuery.getSingleResult(); } @Override public Optional<List<T>> findByCriteria(Criteria clause) {  CriteriaBuilder builder = getEntityManager().getCriteriaBuilder();  Class<T> entityClazz = getEntityClass();  CriteriaQuery<T> criteriaQuery = builder.createQuery(entityClazz);  Root<T> root = null;  if (clause.getEntityClazz() == null)   root = criteriaQuery.from(entityClazz);  else   root = criteriaQuery.from(clause.getEntityClazz());  Restrictions restrictions = new Restrictions();  createCriteria(clause.getWhere(), criteriaQuery, builder, root, null, restrictions);  criteriaQuery.select(root);  if (clause.isDistinct())   criteriaQuery.distinct(true);  TypedQuery<T> typedQuery = getEntityManager().createQuery(criteriaQuery);  if (clause.getStartFrom() > 0)   typedQuery.setFirstResult(clause.getStartFrom());  if (clause.getMaxResults() > 0)   typedQuery.setMaxResults(clause.getMaxResults());  return Optional.of(typedQuery.getResultList()); } public <X> Optional<List<X>> findByCriteria(Criteria clause, Class<X> wrapper) {  CriteriaBuilder builder = getEntityManager().getCriteriaBuilder();  Class<T> entityClazz = getEntityClass();  CriteriaQuery<X> criteriaQuery = builder.createQuery(wrapper);  Root<T> root = null;  if (clause.getEntityClazz() == null)   root = criteriaQuery.from(entityClazz);  else   root = criteriaQuery.from(clause.getEntityClazz());  Restrictions restrictions = new Restrictions();  createCriteria(clause.getWhere(), criteriaQuery, builder, root, wrapper, restrictions);  if (clause.isDistinct())   criteriaQuery.distinct(true);  TypedQuery<X> typedQuery = getEntityManager().createQuery(criteriaQuery);  if (clause.getStartFrom() > 0)   typedQuery.setFirstResult(clause.getStartFrom());  if (clause.getMaxResults() > 0)   typedQuery.setMaxResults(clause.getMaxResults());  return Optional.of(typedQuery.getResultList()); } @Override public Long getCountByMultipleCriteria(Criteria clause) {  CriteriaBuilder builder = getEntityManager().getCriteriaBuilder();  CriteriaQuery<Long> criteriaQuery = builder.createQuery(Long.class);  Map<String, Root<?>> rootMap = new HashMap<>();  Restrictions restrictions = new Restrictions();  clause.getRootMap().forEach((rootKey, rootValue) -> {   Root<?> root = criteriaQuery.from(rootValue.getEntityClass());   createCriteria(rootValue.getListWhere(), criteriaQuery, builder, root, null, restrictions);   rootMap.put(rootKey, root);  });  clause.getRootJoin().forEach(join -> {   restrictions.getPredicateList()     .add(builder.and(builder.equal(rootMap.get(join.getOwnRoot()).get(join.getOwnColumn()),       rootMap.get(join.getJoinRoot()).get(join.getJoinColumn()))));  });  criteriaQuery.where(builder    .and(restrictions.getPredicateList().toArray(new Predicate[restrictions.getPredicateList().size()])));  Root<?> rootCount = rootMap.values().stream().findFirst().get();  if (clause.isDistinct())   criteriaQuery.distinct(true);  criteriaQuery.select(builder.countDistinct(rootCount));  Query query = getEntityManager().createQuery(criteriaQuery);  return (Long) query.getSingleResult(); } public <X> Optional<List<X>> findByMultipleCriteria(Criteria clause, Class<X> wrapper) {  CriteriaBuilder builder = getEntityManager().getCriteriaBuilder();  CriteriaQuery<X> criteriaQuery = builder.createQuery(wrapper);  Map<String, Root<?>> rootMap = new HashMap<>();  Restrictions restrictions = new Restrictions();  clause.getRootMap().forEach((rootKey, rootValue) -> {   Root<?> root = criteriaQuery.from(rootValue.getEntityClass());   createCriteria(rootValue.getListWhere(), criteriaQuery, builder, root, wrapper.getClass(), restrictions);   rootMap.put(rootKey, root);  });  clause.getRootJoin().forEach(join -> {   restrictions.getPredicateList()     .add(builder.and(builder.equal(rootMap.get(join.getOwnRoot()).get(join.getOwnColumn()),       rootMap.get(join.getJoinRoot()).get(join.getJoinColumn()))));  });  criteriaQuery.where(builder    .and(restrictions.getPredicateList().toArray(new Predicate[restrictions.getPredicateList().size()])));  if (clause.isDistinct())   criteriaQuery.distinct(true);  TypedQuery<X> query = getEntityManager().createQuery(criteriaQuery);  if (clause.getStartFrom() > 0)   query.setFirstResult(clause.getStartFrom());  if (clause.getMaxResults() > 0)   query.setMaxResults(clause.getMaxResults());  List<X> list = query.getResultList();  return Optional.of(list); } @Override @SuppressWarnings({ "rawtypes" }) public Optional<List<?>> findByNativeQuery(String query, Map<String, ? extends Object> params, Class clazz) {  Query nativeQuery;  if (clazz == null)   nativeQuery = getEntityManager().createNativeQuery(query);  else   nativeQuery = getEntityManager().createNativeQuery(query, clazz);  Optional.ofNullable(params).ifPresent(p -> {   p.forEach((key, value) -> {    nativeQuery.setParameter(key, value);   });  });  return Optional.of(nativeQuery.getResultList()); } public void setEntityClass(Class<T> entityClass2) {  this.entityClass = entityClass2; } private Restrictions createCriteria(List<Optional<CriteriaWhere>> clause, CriteriaQuery<?> criteria,   CriteriaBuilder builder, Root<?> root, Class<?> clazz, Restrictions restrictions) {  Map<String, Join<?, ?>> joinMap = restrictions.getJoinMap(); // new                  // HashMap<>();  List<Predicate> predicateList = restrictions.getPredicateList(); // new                   // ArrayList<Predicate>();  List<Order> orderList = restrictions.getOrderList(); // new                // ArrayList<Order>();  List<Selection<?>> selectionsList = restrictions.getSelectionsList(); // new                    // ArrayList<Selection<?>>();  clause.stream().forEachOrdered((whereOptional) -> {   whereOptional.ifPresent(where -> {    populateJoin(joinMap, where, root, criteria);    where.getObject().map(joinMap::get).ifPresent(join -> {     where.getSelectItems().stream().forEach(se -> {      selectionsList.add(join.get(se));     });     getPredicates(join, builder, where, false).map(predicateList::addAll);     getPredicateByNull(join, where.getIsNull(), builder, false).map(predicateList::add);     getPredicateByNotNull(join, where.getIsNotNull(), builder, false).map(predicateList::add);     getPredicateByBetween(join, where, builder, false).map(predicateList::add);     getPredicateByNot(join, where, builder, false).map(predicateList::add);     getPredicateByIsIn(join, where, builder, false).map(predicateList::add);     getOrderBy(join, where, builder, false).map(orderList::addAll);     return;    });    if (!where.getObject().isPresent()) {     getPredicates(root, builder, where, true).map(predicateList::addAll);     getPredicateByNull(root, where.getIsNull(), builder, true).map(predicateList::add);     getPredicateByNotNull(root, where.getIsNotNull(), builder, true).map(predicateList::add);     getPredicateByBetween(root, where, builder, true).map(predicateList::add);     getPredicateByNot(root, where, builder, true).map(predicateList::add);     getPredicateByIsIn(root, where, builder, true).map(predicateList::add);     getOrderBy(root, where, builder, true).map(orderList::addAll);     where.getSelectItems().stream().forEach(se -> {      selectionsList.add(root.get(se));     });    }   });  });  criteria.orderBy(orderList);  // where.getSelectItems().stream().forEach(se -> {  // selectionsList.add(root.get(se));  // });  if (clazz != null)   criteria.multiselect(selectionsList);  criteria.where(builder.and(predicateList.toArray(new Predicate[predicateList.size()])));  return restrictions; } /**  * This is to populate join with root entity.  *   * @param joinMap  * @param where  * @param root  */ private void populateJoin(Map<String, Join<?, ?>> joinMap, CriteriaWhere where, Root<?> root,   CriteriaQuery<?> criteria) {  where.getObject().ifPresent(joinTable -> {   where.getContainer().ifPresent(joinContainer -> {    // if container is there, already root is join with some other    // entity. now we have to join with already joined entity and    // not to root.    joinMap.putIfAbsent(joinTable, joinMap.get(joinContainer).join(joinTable, JoinType.INNER));    return;   });   // if there is no container, join with root entity   joinMap.putIfAbsent(joinTable, root.join(joinTable, JoinType.INNER));  }); } /**  * To populate Order by element.  *   * @param rootOrJoin  * @param where  * @param builder  * @param check  * @return  */ private Optional<List<Order>> getOrderBy(Object rootOrJoin, CriteriaWhere where, CriteriaBuilder builder,   boolean check) {  List<Order> pList = new ArrayList<>();  where.getOrderBy().forEach((element) -> {   pList.add(getOrderByOption(rootOrJoin, element.getOrderBy(), builder, element.isAscending(), check));  });  return Optional.of(pList); } private Optional<List<Predicate>> getPredicates(Object object, CriteriaBuilder builder, CriteriaWhere where,   boolean check) {  List<Predicate> pList = new ArrayList<>();  where.getCriteriaMap().forEach((column, columnCriteria) -> {   if (!check) {    Join<?, ?> join = (Join<?, ?>) object;    getPredicateByJoin(join, builder, columnCriteria).map(pList::add);   } else {    Root<?> root = (Root<?>) object;    getPredicateByRoot(root, builder, columnCriteria).map(pList::add);   }  });  return Optional.of(pList); } @SuppressWarnings("unchecked") private Optional<Predicate> getPredicateByJoin(Join<?, ?> join, CriteriaBuilder builder, CriteriaElement where) {  if (where.getOption() == null)   return Optional.empty();  List<Predicate> pList = new ArrayList<>();  return where.getElementValue().map(value -> {   @SuppressWarnings("rawtypes")   Class<? extends Comparable> clazz = getPrimitiveClass(value);   switch (where.getOption()) {   case EQUALS:    if (value instanceof List<?>) {     List<?> vList = (List<?>) value;     vList.stream().forEach(v -> {      pList.add(builder.equal(join.get(where.getElementName()), v));     });     return Optional.of(builder.or(pList.toArray(new Predicate[pList.size()])));    }    return Optional.of(builder.equal(join.get(where.getElementName()), clazz.cast(value)));   case NOT_EQUALS:    if (value instanceof List<?>) {     List<?> vList = (List<?>) value;     vList.stream().forEach(v -> {      pList.add(builder.notEqual(join.get(where.getElementName()), v));     });     return Optional.of(builder.or(pList.toArray(new Predicate[pList.size()])));    }    return Optional.of(builder.notEqual(join.get(where.getElementName()), clazz.cast(value)));   case GREATER_EQUAL:    return Optional.of(builder.greaterThan(join.get(where.getElementName()), clazz.cast(value)));   case GREATER_THAN:    return Optional.of(builder.greaterThanOrEqualTo(join.get(where.getElementName()), clazz.cast(value)));   case LESSER_EQUAL:    return Optional.of(builder.lessThanOrEqualTo(join.get(where.getElementName()), clazz.cast(value)));   case LESSER_THAN:    return Optional.of(builder.lessThan(join.get(where.getElementName()), clazz.cast(value)));   case LIKE:    if (value instanceof List<?>) {     List<?> vList = (List<?>) value;     vList.stream().forEach(v -> {      pList.add(builder.like(join.get(where.getElementName()), v.toString()));     });     return Optional.of(builder.or(pList.toArray(new Predicate[pList.size()])));    }    return Optional.of(builder.like(join.get(where.getElementName()), value.toString()));   }   return null;  }).orElse(Optional.empty()); } @SuppressWarnings("unchecked") private Optional<Predicate> getPredicateByRoot(Root<?> root, CriteriaBuilder builder, CriteriaElement where) {  if (where.getOption() == null)   return Optional.empty();  List<Predicate> pList = new ArrayList<>();  return where.getElementValue().map(value -> {   @SuppressWarnings("rawtypes")   Class<? extends Comparable> clazz = getPrimitiveClass(value);   switch (where.getOption()) {   case EQUALS:    if (value instanceof List<?>) {     List<?> vList = (List<?>) value;     vList.stream().forEach(v -> {      pList.add(builder.equal(root.get(where.getElementName()), v));     });     return Optional.of(builder.or(pList.toArray(new Predicate[pList.size()])));    }    return Optional.of(builder.equal(root.get(where.getElementName()), value));   case NOT_EQUALS:    if (value instanceof List<?>) {     List<?> vList = (List<?>) value;     vList.stream().forEach(v -> {      pList.add(builder.notEqual(root.get(where.getElementName()), v));     });     return Optional.of(builder.or(pList.toArray(new Predicate[pList.size()])));    }    return Optional.of(builder.notEqual(root.get(where.getElementName()), value));   case GREATER_EQUAL:    return Optional.of(builder.greaterThan(root.get(where.getElementName()), clazz.cast(value)));   case GREATER_THAN:    return Optional.of(builder.greaterThanOrEqualTo(root.get(where.getElementName()), clazz.cast(value)));   case LESSER_EQUAL:    return Optional.of(builder.lessThanOrEqualTo(root.get(where.getElementName()), clazz.cast(value)));   case LESSER_THAN:    return Optional.of(builder.lessThan(root.get(where.getElementName()), clazz.cast(value)));   case LIKE:    if (value instanceof List<?>) {     List<?> vList = (List<?>) value;     vList.stream().forEach(v -> {      pList.add(builder.like(root.get(where.getElementName()), value.toString()));     });     return Optional.of(builder.or(pList.toArray(new Predicate[pList.size()])));    }    return Optional.of(builder.like(root.get(where.getElementName()), value.toString()));   }   return null;  }).orElse(Optional.empty()); } private Optional<Predicate> getPredicateByNull(Object obj, Optional<String> where, CriteriaBuilder builder,   boolean check) {  return where.map(notNullValue -> {   if (check)    return Optional.of(builder.isNull(((Root<?>) obj).get(notNullValue)));   return Optional.of(builder.isNull(((Join<?, ?>) obj).get(notNullValue)));  }).orElse(Optional.empty()); } @SuppressWarnings("unchecked") private Optional<Predicate> getPredicateByBetween(Object obj, CriteriaWhere where, CriteriaBuilder builder,   boolean check) {  return where.getBetween().map(between -> {   @SuppressWarnings("rawtypes")   Class<? extends Comparable> clazz = getPrimitiveClass(where.getBetweenFrom());   if (check)    return Optional.of(builder.between(((Root<?>) obj).get(between), clazz.cast(where.getBetweenFrom()),      clazz.cast(where.getBetweenTo())));   return Optional.of(builder.between(((Join<?, ?>) obj).get(between), clazz.cast(where.getBetweenFrom()),     clazz.cast(where.getBetweenTo())));  }).orElse(Optional.empty()); } /**  * @param obj  * @param where  * @param builder  * @param check  * @return  */ private Optional<Predicate> getPredicateByNot(Object obj, CriteriaWhere where, CriteriaBuilder builder,   boolean check) {  return where.getIsNotIn().map(not -> {   if (check)    return Optional.of(builder.not(((Root<?>) obj).get(where.getIsNotElement()).in(not)));   return Optional.of(builder.not(((Join<?, ?>) obj).get(where.getIsNotElement()).in(not)));  }).orElse(Optional.empty()); } private Optional<Predicate> getPredicateByIsIn(Object obj, CriteriaWhere where, CriteriaBuilder builder,   boolean check) {  return where.getIsIn().map(val -> {   if (check)    return Optional.of(((Root<?>) obj).get(where.getIsInElement()).in(val));   return Optional.of(((Join<?, ?>) obj).get(where.getIsInElement()).in(val));  }).orElse(Optional.empty()); } @SuppressWarnings({ "unchecked" }) private Class<? extends Comparable<?>> getPrimitiveClass(Object value) {  Class<? extends Comparable<?>> clazz = (Class<? extends Comparable<?>>) value.getClass();  return clazz; } /**  * @param obj  * @param where  * @param builder  * @param check  * @return  */ private Optional<Predicate> getPredicateByNotNull(Object obj, Optional<String> where, CriteriaBuilder builder,   boolean check) {  return where.map(notNullValue -> {   if (check)    return Optional.of(builder.isNotNull(((Root<?>) obj).get(notNullValue)));   return Optional.of(builder.isNotNull(((Join<?, ?>) obj).get(notNullValue)));  }).orElse(Optional.empty()); } /**  * @param object  * @param where  * @param builder  * @return  */ private Order getOrderByOption(Object object, String orderBy, CriteriaBuilder builder, boolean ascending,   boolean check) {  if (check) {   if (ascending)    return builder.asc(((Root<?>) object).get(orderBy));   return builder.desc(((Root<?>) object).get(orderBy));  }  if (ascending)   return builder.asc(((Join<?, ?>) object).get(orderBy));  return builder.desc(((Join<?, ?>) object).get(orderBy)); } @Override public int updateByNativeQuery(String query, Map<String, ? extends Object> params) {  Query nativeQuery = getEntityManager().createNativeQuery(query);  params.forEach((key, value) -> {   nativeQuery.setParameter(key, value);  });  return nativeQuery.executeUpdate(); } @Override public int updateByNamedQuery(String queryName, Map<String, ? extends Object> params) {  Query namedQuery = getEntityManager().createNamedQuery(queryName);  params.forEach((key, value) -> {   namedQuery.setParameter(key, value);  });  return namedQuery.executeUpdate(); } @Override public int executeNamedQuery(String queryName, Map<String, ? extends Object> params) {  return updateByNamedQuery(queryName, params); } @Override @SuppressWarnings({ "rawtypes" }) public Optional<List<?>> findByNativeQuery(NativeCriteria nCriteria, Map<String, ? extends Object> params,   Class clazz) {  Query nativeQuery;  if (clazz == null)   nativeQuery = getEntityManager().createNativeQuery(nativeBuilder.getCriteriaQuery(nCriteria));  else   nativeQuery = getEntityManager().createNativeQuery(nativeBuilder.getCriteriaQuery(nCriteria), clazz);  Optional.ofNullable(params).ifPresent(p -> {   p.forEach((key, value) -> {    String val = value.toString().replaceAll("\\*", "%");    nativeQuery.setParameter(key, val);   });  });  if (nCriteria.getMaxResults() > 0)   nativeQuery.setMaxResults(nCriteria.getMaxResults());  if (nCriteria.getStartFrom() > 0)   nativeQuery.setFirstResult(nCriteria.getStartFrom());  return Optional.of(nativeQuery.getResultList()); }}
