/** *  */package com.bolla.sri.rest.api;import java.util.HashMap;import java.util.Map;import java.util.Optional;import java.util.UUID;import javax.inject.Inject;import javax.ws.rs.core.Response;import javax.ws.rs.core.Response.ResponseBuilder;import com.bolla.sri.base.domain.BaseEntity;import com.bolla.sri.base.domain.IEntity;import com.bolla.sri.base.domain.ModifyInfo;import com.bolla.sri.base.pagination.QueryRequest;import com.bolla.sri.base.pagination.QueryResponse;import com.bolla.sri.base.service.GenericService;import com.bolla.sri.error.sriError;import com.bolla.sri.error.type.ErrorType;import com.bolla.sri.rest.base.BaseRequest;import com.bolla.sri.rest.response.sriResponseHelper;public abstract class AbstractAPIImpl<P extends IEntity, B extends IEntity, M extends IEntity>  implements IsriAPI<BaseRequest<B>> { protected String universalId; protected String requestId; @Inject private sriResponseHelper responseHelper; /**  * Entity or List of Entity  *   * @param container  * @return Response  */ public Response get(int pageId, int pageSize, String filter, String sortOrder, String sortBy, String all) {  QueryRequest container = buildQuery(pageId, pageSize, filter, sortOrder, sortBy, all);  return get(container); } public AbstractAPIImpl() { } /**  * Submits an Mod Entity to submit for Review process.  *   * @param entity  * @return Response  */ @Override public Response submit(BaseRequest<B> t, String modifiedBy) {  t.populate(modifiedBy, requestId);  BaseEntity entity = (BaseEntity) getService().submit((M) t.getEntity());  return sendSubmitResponse(entity); } @Override public Response edit(UUID id, String userId, boolean fromMaintenance) {  BaseEntity entity = (BaseEntity) getService().edit(id, userId.toUpperCase(), fromMaintenance);  Map<String, Object> revisionMap = populateModifyInfo(entity.getModifyInfo());  return responseHelper.successResponse(revisionMap, entity); } /**  * Saves the Mod Entity and process the Review process.  *   * @param entity  * @return Response  */ @Override public Response save(BaseRequest<B> t, String modifiedBy) {  t.populate(modifiedBy, requestId);  getService().save((M) t.getEntity());  return responseHelper.successResponse(); } /**  * Delete the entity based on UUID.  *   * @param id  * @param info  * @return Response  */ @Override public Response delete(BaseRequest<B> t, UUID id, String modifiedBy) {  t.populate(modifiedBy, requestId);  getService().delete(id, t.getModifyInfo());  Map<String, Object> map = new HashMap<>();  map.put("Id", id);  return responseHelper.successResponse(map); } /**  * Revert the entity based on UUID.  *   * @param id  * @param info  * @return Response  */ @Override public Response revert(UUID id, String modifiedBy) {  getService().revert(id, modifiedBy.toUpperCase());  return responseHelper.successResponse(); } /**  * Creates the Mod Entity based on Modify Info information.  *   * @param modifyInfo  * @return Response  */ @Override public Response create(BaseRequest<B> t, String modifiedBy) {  t.getModifyInfo().setModifiedBy(modifiedBy);  BaseEntity b = (BaseEntity) getService().create(t.getModifyInfo());  Map<String, Object> revisionMap = populateModifyInfo(b.getModifyInfo());  return responseHelper.successResponse(revisionMap, b); } @Override public Response view(UUID id) {  return getService().findProd(id).map(data -> {   return responseHelper.successResponse(data);  }).orElseThrow(() -> new sriError(ErrorType.VALIDATION_ERROR, "Entity doesn't exist.")); } /**  * Creates the Mod Entity based on Modify Info information.  *   * @param modifyInfo  * @return Response  */ @Override public Response create(String modifiedBy) {  ModifyInfo info = new ModifyInfo();  info.setModifiedBy(modifiedBy);  BaseEntity b = (BaseEntity) getService().create(info);  Map<String, Object> revisionMap = populateModifyInfo(b.getModifyInfo());  return responseHelper.successResponse(revisionMap, b); } /**  * Save the Mod entity and doesn't process review process.  *   * @param entity  * @return Response  */ @Override public Response persist(BaseRequest<B> t, String modifiedBy) {  t.populate(modifiedBy, null);  t.getModifyInfo().setModifiedBy(modifiedBy);  getService().persist((M) t.getEntity());  Map<String, Object> revisionMap = populateModifyInfo(t.getModifyInfo());  return responseHelper.successResponse(revisionMap, null); } /**  * Entity or List of Entity  *   * @param container  * @return Response  */ protected Response get(QueryRequest container) {  QueryResponse<P> paginationResponse = getService().get(container);  return responseHelper.successResponse(paginationResponse.getCount(), paginationResponse.getList(),    paginationResponse.getEntity()); } /**  * Builds the Pagination container object.  *   * @param pageId  * @param pageSize  * @param sortBy  * @param sortOrder  * @param filter  * @return PaginationContainer.  */ private QueryRequest buildQuery(int pageId, int pageSize, String filter, String sortOrder, String sortBy,   String all) {  QueryRequest container = new QueryRequest();  if (all != null) {   pageId = 0;   pageSize = 0;  }  container.setPageId(pageId);  container.setPageSize(pageSize);  container.setSortField(sortBy);  container.setSortOrder(sortOrder);  container.setFilter(filter);  return container; } protected <T extends BaseEntity> Response sendSubmitResponse(T entity) {  Map<String, Object> responseMap = new HashMap<>();  responseMap.put("Id", entity.getId());  Map<String, Object> revisionMap = new HashMap<>();  revisionMap.put("revisionId", entity.getModifyInfo().getRevisionId());  revisionMap.put("changeId", entity.getModifyInfo().getChangeId());  responseMap.put("Revision", revisionMap);  return responseHelper.successResponse(responseMap, null); } protected Map<String, Object> populateModifyInfo(ModifyInfo info) {  Map<String, Object> revisionMap = new HashMap<>();  Optional.ofNullable(info.getRevisionId()).ifPresent(rId -> revisionMap.put("revisionId", rId));  Optional.ofNullable(info.getParentRevisionId()).ifPresent(rId -> revisionMap.put("parentRevisionId", rId));  Optional.ofNullable(info.getChangeId()).ifPresent(rId -> revisionMap.put("changeId", rId));  return revisionMap; } protected abstract GenericService<P, M> getService();  @Override public Response getPdfReport(String type, UUID uuid) {  QueryResponse<byte[]> response1=null;  if("PROD".equalsIgnoreCase(type)){    response1 =getService().getPdfReport(uuid,true);  }else{    response1 =getService().getPdfReport(uuid,false);  }  //Response successResponse = responseHelper.successResponse(response);    ResponseBuilder response = Response.ok(response1.getEntity());  response.cookie();  response.header("Content-Disposition",   "attachment; filename=pdfentity.pdf");    response.header("Access-Control-Allow-Origin", "*");     response.header("Access-Control-Allow-Credentials", "true");     response.header("Access-Control-Allow-Methods", "GET,HEAD,OPTIONS,POST,PUT");     response.header("Access-Control-Allow-Headers", "Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers");  //responsebul.header("Access-Control-Allow-Headers", "origin, content-type, accept, authorization");  //responsebul.header("Access-Control-Allow-Headers", "origin, content-type, accept, authorization");// successResponse.ok().header("Content-Disposition", "inline; filename=file.pdf");  return response.build(); //re  // TODO Auto-generated method stub  //return IsriAPI.super.getPdfReport(type, uuid); }}package com.bolla.sri.rest.api;import java.util.UUID;import javax.annotation.security.RolesAllowed;import javax.ws.rs.GET;import javax.ws.rs.Path;import javax.ws.rs.PathParam;import javax.ws.rs.Produces;import javax.ws.rs.core.Response;import com.bolla.sri.error.sriError;public interface IsriAPI<BaseRequest> { public static final String UNIVERSAL_ID = "SM_UNIVERSALID"; public static final String REQUEST_ID = "REQUEST_ID"; public static final String SERVICE_ID = "service"; public static final String PAGE = "pageId"; public static final String LIMIT = "pageSize"; public static final String FILTER = "filter"; public static final String SORTORDER = "sortOrder"; public static final String SORTBY = "sortBy"; public static final String ALL = "all"; public static final String ID = "Id"; public static final String ACTION = "action"; public static final String ACTION_CANCEL = "cancel"; public static final String ACTION_EDIT = "edit"; public static final String COMMENTS = "comments"; public static final String EFFECTIVE_DATE = "effectiveDate"; public static final String STATUS_ID = "statusId"; default Response submit(BaseRequest t, String modifiedBy) {  throw new sriError("Must override in sub interface"); } default Response create(String modifiedBy) {  throw new sriError("Must override in sub interface"); } default Response get(int page, int pageSize, String filter, String order, String sortField, String all) {  throw new sriError("Must override in sub interface"); } default Response save(BaseRequest t, String modifiedBy) {  throw new sriError("Must override in sub interface"); } default Response revert(UUID id, String modifiedBy) {  throw new sriError("Must override in sub interface"); } default Response delete(BaseRequest t, UUID id, String modifiedBy) {  throw new sriError("Must override in sub interface"); } default Response edit(UUID id, String userId, boolean fromMaintenance) {  throw new sriError("Must override in sub interface"); } default Response view(UUID id) {  throw new sriError("Must override in sub interface"); } default Response create(BaseRequest t, String modifiedBy) {  throw new sriError("Must override in sub interface"); } default Response persist(BaseRequest t, String modifiedBy) {  throw new sriError("Must override in sub interface"); }  default Response getPdfReport(String type, UUID uuid) {  throw new sriError("Must override in sub interface"); }  }
